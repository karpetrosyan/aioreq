{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Aioreq is a Python low-level asynchronous HTTP client library. It is built on top of TCP sockets and implements the HTTP protocol entirely on his own.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Click here</p>"},{"location":"#install","title":"Install","text":"<pre><code>$ pip install aioreq\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt;\n&gt;&gt;&gt; cl = aioreq.Client()\n&gt;&gt;&gt;\n&gt;&gt;&gt; resp = asyncio.run(\n... cl.get('https://www.google.com')\n... )\n&gt;&gt;&gt; resp\n&lt;Response 200 OK&gt;\n&gt;&gt;&gt; resp.status\n200\n&gt;&gt;&gt; resp.status_message\n'OK'\n&gt;&gt;&gt; resp.request\n&lt;Request GET www.google.com&gt;\n&gt;&gt;&gt; headers = resp.headers # dict\n&gt;&gt;&gt; body = resp.content # bytes object\n</code></pre> <p>or you can use the default client, which is a synchoronous wrapper for an asynchronous interface</p> <pre><code>&gt;&gt;&gt; aioreq.get('https://www.google.com')\n&lt;Response 200 OK&gt;\n</code></pre> <p>Alternatively, the best practice is to use a Context manager. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt;\n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as cl:\n...         return await cl.get('https://google.com')\n&gt;&gt;&gt; asyncio.run(main())\n&lt;Response 200 OK&gt;\n</code></pre></p>"},{"location":"#more-advanced-usage","title":"More advanced usage","text":"<p>This code will asynchronously send 100 get requests to <code>google.com</code>, which is much faster than synchronous libraries. Also, the client persistent connection mechanism was disabled, so that a connection would be opened for each request.</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt;\n&gt;&gt;&gt; async def main():\n...     async with aioreq.http.Client(persistent_connections=False) as cl:\n...         tasks = []\n...         for j in range(100):\n...             tasks.append(\n...                 asyncio.create_task(\n...                     cl.get('https://www.google.com/', )\n...                 )\n...             )\n...         await asyncio.gather(*tasks)\n&gt;&gt;&gt; asyncio.run(main())\n</code></pre>"},{"location":"#streams","title":"Streams","text":"<p>We occasionally use the HTTP protocol to download videos, photos, and possibly files. When downloading very large files, Stream must be used instead of the default Client. When a client downloads videos or files, the server responds with all information including headers, status code, status message, and full body, which can be very large. As a result, we cannot store it in RAM. Stream only returns a portion of the body per iteration, allowing us to write it to disk, then receive another portion and solve the ram overflow problem.</p> <p>There is some fundamental Stream usage. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; from aioreq import Request\n&gt;&gt;&gt; \n&gt;&gt;&gt; async def main():\n...     req = Request(url=\"https://www.youtube.com\", method=\"GET\")\n...     async with aioreq.StreamClient(request=req) as response:\n...         assert response.status == 200\n...         async for chunk in response.content:\n...             assert chunk   \n&gt;&gt;&gt; asyncio.run(main())\n</code></pre></p>"},{"location":"#middlewares","title":"Middlewares","text":"<p>Aioreq now supports 'middleware' power.</p>"},{"location":"#the-first-steps-with-middleware","title":"The first steps with middleware","text":"<p>Aioreq provides default middlewares to each client. We can see that middlewares by importing 'default_middlewares'  variable. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; aioreq.middlewares.default_middlewares\n('RetryMiddleWare', 'RedirectMiddleWare', 'CookiesMiddleWare', 'DecodeMiddleWare', 'AuthenticationMiddleWare')\n</code></pre> The first item on this list represents the first middleware that should handle our request (i.e. the closest middleware to our client), while the last index represents the closest middleware to the server.</p> <p>To override the default middlewares, we can pass our middlewares to the Client. <pre><code>&gt;&gt;&gt; client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])\n</code></pre></p> <p>This client will no longer redirect or retry responses.</p> <p>Also, because aioreq stores middlewares in Client objects as linked lists, we can simply change the head of that linked list to skip the first middleware. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'RetryMiddleWare'\n&gt;&gt;&gt;\n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'RedirectMiddleWare'\n&gt;&gt;&gt; \n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'CookiesMiddleWare'\n</code></pre></p> <p>or  <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware.next_middleware\n&gt;&gt;&gt; # alternative for client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])\n</code></pre></p>"},{"location":"#create-your-own-middlewares","title":"Create your own middlewares!","text":"<p>All 'aioreq' middlewares must be subclasses of the class 'middlewares.MiddleWare'</p> <p>MiddleWare below would add 'test-md' header if request domain is 'www.example.com' <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomMiddleWare(aioreq.middlewares.MiddleWare):\n...     async def process(self, request, client):\n...         if request.host == 'www.example.com':\n...             request.headers['test_md'] = 'test'\n...         await self.next_middleware.process(request, client)\n...\n&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares = CustomMiddleWare(next_middleware=client.middlewares)\n</code></pre> Our CustomMiddleWare will now be the first middleware (i.e. closest to the client). Because 'aioreq' middlewares are stored as linked lists, this pattern works (i.e. same as linked list insert method).</p> <p>Alternatively, we can alter the list of middlewares that the client receives. <pre><code>&gt;&gt;&gt; client = aioreq.Client(middlewares = (CustomMiddleWare, ) + aioreq.middlewares.default_middlewares)\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'CustomMiddleWare'\n</code></pre></p>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>Aioreq is a very fast library, and we compared it to other Python libraries to demonstrate its speed.</p> <p>I used httpx to compare speed.</p>"},{"location":"#benchmark-run","title":"Benchmark run","text":"<p>First, clone aioreq repository.</p> <p>Then...</p> <pre><code>$ cd aioreq\n$ python -m venv venv\n$ source ./venv/bin/activate\n$ pip install '.[dev]'\n$ cd benchmarks\n$ ./run_tests\n</code></pre>"},{"location":"#benchmark-results","title":"Benchmark results","text":"<p>This is the average execution time of each library for 200 asynchronous requests where responses was received without chunked transfer encoding. </p> <p>Benchmark settings.</p> <ul> <li>Url - http://www.google.com</li> <li>Requests count - 200</li> </ul>"},{"location":"#with-content-length","title":"With <code>Content-Length</code>","text":"<pre><code>$ cd becnhmarks\n$ ./run_tests\nTests with module loading\n---------------------------\naioreq benchmark\n\nreal    0m1.893s\nuser    0m0.777s\nsys     0m0.063s\n---------------------------\nhttpx benchmark\n\nreal    0m2.448s\nuser    0m0.840s\nsys     0m0.151s\n</code></pre>"},{"location":"#with-transfer-encoding-chunked","title":"With <code>Transfer-Encoding: Chunked</code>","text":"<p>This is the average execution time of each library for 200 asynchronous requests where responses was received with chunked transfer encoding. </p> <p>Benchmark settings.</p> <ul> <li>Url - https://www.youtube.com</li> <li>Requests count - 200</li> </ul> <pre><code>$ cd benchmarks\n$ ./run_tests\nTests with module loading\n---------------------------\naioreq benchmark\n\nreal    0m2.444s\nuser    0m1.090s\nsys     0m0.089s\n---------------------------\nhttpx benchmark\n\nreal    0m2.990s\nuser    0m1.254s\nsys     0m0.127s\n</code></pre> <p>As you can see, the synchronous code lags far behind when we make many requests at the same time.</p>"},{"location":"#keylog","title":"Keylog","text":"<p>If the SSLKEYLOGFILE environment variable is set, Aioreq will write keylogs to it.</p> <pre><code>$ export SSLKEYLOGFILE=logs\n</code></pre> <p>Then just run python script.</p> <p><pre><code>$ python aioreq_app.py\n$ ls -l\ntotal 8\n-rw-r--r-- 1 user user  94 Dec  5 17:19 aioreq_app.py\n-rw-r--r-- 1 user user 406 Dec  5 17:19 logs\n</code></pre> Now, the 'logs' file contains keylogs that can be used to decrypt your TLS/SSL traffic with a tool such as 'wireshark'.</p>"},{"location":"#authentication","title":"Authentication","text":"<p>If the <code>auth</code> parameter is included in the request, Aioreq will handle authentication. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def send_req():\n...     async with aioreq.Client() as cl:\n...         return await cl.get('http://httpbin.org/basic-auth/foo/bar', auth=('foo', 'bar'))\n&gt;&gt;&gt; resp = asyncio.run(send_req())\n&gt;&gt;&gt; resp.status\n200\n</code></pre> Parameter 'auth' should be a tuple with two elements: password and login.</p> <p>Authentication is enabled by 'AuthenticationMiddleWare,' so exercise caution when managing middlewares manually.</p>"},{"location":"#supported-features","title":"Supported Features","text":"<p>Aioreq support basic features to work with HTTP/1.1.More functionality will be available in future releases. This is the latest version features.</p> <ul> <li>Keep-Alive (Persistent Connections)</li> <li>Middlewares</li> <li>Keylogs</li> <li>Authentication</li> <li>Cookies</li> <li>Automatic accepting and decoding responses. Using <code>Accept-Encoding</code> header</li> <li>HTTPS support, TLS/SSL Verification</li> <li>Request Timeouts</li> </ul>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#headers","title":"Headers","text":"<p>To work with headers, 'Aioreq' provides special 'BaseHeader' subclasses.</p> <p>We can set the Accept header by simply entering it in the 'Headers' field, as shown here. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; headers = aioreq.Headers({'Accept' : 'application/json'})\n</code></pre></p> <p>We can also prioritize values. <pre><code>&gt;&gt;&gt; headers = aioreq.Headers({\"Accept\" : \"application/json; q=1\"})\n</code></pre></p> <p>If you want, you can use the dictionary interface. <pre><code>&gt;&gt;&gt; headers = aioreq.Headers()\n&gt;&gt;&gt; headers['accept'] = 'application/json; q=1'\n</code></pre></p> <p>However, aioreq's special 'BaseHeader' subclasses can also be used.</p> <p>Why should you use header classes? You can use the editor autocomplete to add headers without knowing anything about header syntax.</p> <pre><code>&gt;&gt;&gt; from aioreq import headers as aioheaders\n&gt;&gt;&gt; headers = aioreq.Headers()\n&gt;&gt;&gt; headers.add_header(aioheaders.Accept(\n...    (aioheaders.MimeType.json, 1),\n... ))\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/json; q=1\n</code></pre> <p>First, we should import headers. <pre><code>&gt;&gt;&gt; from aioreq import headers as aioheaders\n</code></pre></p> <p>Then, make a <code>BaseHeader</code> object. <pre><code>&gt;&gt;&gt; header_obj = aioheaders.Accept(\n...     (aioheaders.MimeType.html, 0.5)\n... )\n</code></pre></p> <p>This is the 'Accept' header object, with the value 'application/html; q=0.5,'  where 'q' is the priority for that 'MimeType.' Finally, insert this header into the 'Headers' object. <pre><code>&gt;&gt;&gt; headers.add_header(header_obj)\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/html; q=0.5\n</code></pre></p> <p>We can also add multiple 'Values' in this manner. <pre><code>&gt;&gt;&gt; header_obj = aioheaders.Accept(\n...     (aioheaders.MimeType.html, 0.6),\n...     (aioheaders.MimeType.json, 0.8)\n... )\n&gt;&gt;&gt; headers.add_header(header_obj)\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/html; q=0.6, application/json; q=0.8\n</code></pre></p> <p>That is, the client accepts both html and json responses, but please provide me with a json response if you support both.</p>"},{"location":"advanced/#client","title":"Client","text":"<p>The <code>Client</code> class offers a high-level API for sending and receiving HTTP/1.1 requests. That is how the 'Client' class works.</p> <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         ...\n</code></pre> <p>To change some default arguments or enable persistent connections, pass arguments through the 'Client.'</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client(headers = {'test' : 'test1'}) as client:\n...         await client.get('http://example.com') # This request includes the 'test' header, which was added by the client.\n...         await client.get('http://example.com', headers = {'test' : 'test2'}) # Overrides the client headers.\n</code></pre> <p>You can also use HTTP/1.1's main feature, persistent connections, to save a significant amount of memory and system  resources by reusing connections rather than creating new ones.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client(persistent_connections = True) as client:\n...         ... # This client can now reuse previously opened connections.\n</code></pre> <p>In order to improve request performance, 'Aioreq' instructs the server to encode HTTP messages if possible.</p> <p>This feature is very useful, but you can disable it for specific 'Client' objects if you want.</p> <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; defaults = aioreq.middlewares.default_middlewares\n&gt;&gt;&gt; custom_middlewares = [md for md in defaults if md != 'DecodeMiddleWare']\n&gt;&gt;&gt; client = aioreq.Client(middlewares=custom_middlewares)\n</code></pre>"},{"location":"quickstart/","title":"Usage","text":""},{"location":"quickstart/#basic-usage","title":"Basic usage","text":"<p>First, import aioreq. <pre><code>&gt;&gt;&gt; import aioreq\n</code></pre> This is a very basic example of usage. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; response = asyncio.run(client.get('http://google.com'))\n&gt;&gt;&gt; response\n&lt;Response 200 OK&gt;\n</code></pre></p> <p>The client's context manager stores all of his connections and files and handles cleanup when we're done with them. This is a suggested setup.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         response = client.get(\"http://google.com\")\n</code></pre> <p>This is how 'response' objects are used. <pre><code>&gt;&gt;&gt; response.request\n&lt;Request GET www.google.com&gt;\n&gt;&gt;&gt; response.status\n200\n&gt;&gt;&gt; response.status_message\n'OK'\n</code></pre></p> <p><code>Aioreq</code> provides complete header control. <pre><code>response.headers\nHeaders:\ndate: Thu, 01 Dec 2022 05:29:09 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text/html; charset=ISO-8859-1\ncross-origin-opener-policy-report-only: same-origin-allow-popups; report-to=\"gws\"\nreport-to: {\"group\":\"gws\",\"max_age\":2592000,\"endpoints\":[{\"url\":\"https://csp.withgoogle.com/csp/report-to/gws/other\"}]}\np3p: CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\"\ncontent-encoding: gzip\nserver: gws\ncontent-length: 16642\nx-xss-protection: 0\nx-frame-options: SAMEORIGIN\n</code></pre> As you can see, there is a 'content-encoding' header, and it is gzip. Aioreq can automatically handle many types of encodings and can easily receive compressed data instead of raw data.</p> <p>This is how accessing the body message works. <pre><code>&gt;&gt;&gt; body = response.content\n&gt;&gt;&gt; type(body) == bytes\nTrue\n&gt;&gt;&gt; type(len(body)) == int\nTrue\n</code></pre> As you can see, the 'content-length' header has the value '16622,' indicating that the incoming data length should be  16622, but our content field contains significantly more data than expected. It's because 'Aioreq' 'automatically told  the server' to use compression for better performance, which is then decoded on the client.</p> <p>If you need to receive very lots of data, use 'StreamClient' instead of 'Client.' 'StreamClient' methods return 'async iterators,' which allow us to receive only a small amount of data per iteration and write it to the hard drive, saving a lot of memory.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     import tempfile\n...     file = tempfile.TemporaryFile()\n...     req = aioreq.Request(\"https://google.com\", method=\"GET\")\n...     async with aioreq.StreamClient(request = get) as resp:\n...         async for chunk in resp.content:\n...             file.write(chunk)\n...     file.close()\n</code></pre>"},{"location":"quickstart/#headers","title":"Headers","text":"<p>This is how Headers are set up. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; headers = aioreq.Headers()\n</code></pre></p> <p>'Aioreq Headers' are objects that are similar to dictionary objects but have some differences.</p> <ul> <li> <p>case-insensitivity <pre><code>&gt;&gt;&gt; headers['my-header'] = 'my-text'\n&gt;&gt;&gt; headers['MY-HeAdEr']\n'my-text'\n</code></pre></p> </li> <li> <p>pretty-print <pre><code>&gt;&gt;&gt; headers\nHeaders:\nmy-header: my-text\n</code></pre></p> </li> <li> <p>aioreq header types compatibility <pre><code>&gt;&gt;&gt; from aioreq import headers\n&gt;&gt;&gt; new_header = aioreq.Headers()\n&gt;&gt;&gt; header_obj = headers.Accept((headers.MimeType.json, 0.5))\n&gt;&gt;&gt; new_header.add_header(header_obj)\n&gt;&gt;&gt; new_header\nHeaders:\naccept:  application/json; q=0.5\n</code></pre></p> </li> </ul>"},{"location":"quickstart/#requests","title":"Requests","text":"<p>There is how to make simple GET request. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         await client.get(\"https://google.com\")\n</code></pre></p> <p>Alternatively, we can create a Request object and send it directly through the client. <pre><code>&gt;&gt;&gt; async def example():\n...     req = aioreq.Request(\n...         url='https://google.com/',\n...         method='GET',\n...         )\n...     await cl.send_request(req)\n</code></pre></p> <p>What about sending path parameters? <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...     url='https://google.com/',\n...     method='GET',\n...     params=(('example_1', 10 ), ('example_2', 20))\n...    )\n</code></pre></p> <p>and perhaps a body message <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...            url='https://google.com',\n...            method='GET',\n...            content=b'Text for the body')\n</code></pre></p> <p>If we want to send a JSON request, we must include the content-type parameter. <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...        url='https://google.com',\n...        method='GET',\n...        content=b'{\"test\": \"test\"}',\n...        headers = {'content-type': 'application/json'})\n</code></pre></p> <p>Alternatively, we can use JsonRequest. <pre><code>&gt;&gt;&gt; req = aioreq.JsonRequest(\n...        url='https://google.com',\n...        method='GET',\n...        content=b'{\"test\": \"test\"}',\n...       )\n</code></pre></p> <p>Each response object contains his request. The 'request' field provides access to the Request object. <pre><code>&gt;&gt;&gt; response.request\n&lt;Request GET www.google.com&gt;\n</code></pre></p>"},{"location":"quickstart/#clients","title":"Clients","text":"<p>Initialization of the client. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n</code></pre></p> <p>or <pre><code>&gt;&gt;&gt; async def example():\n...     async with aioreq.Client() as client:\n...         ...\n</code></pre></p> <p>You can provide the client with default headers. The client employs his headers in all of his requests.</p> <pre><code>&gt;&gt;&gt; client = aioreq.Client(headers={'Accept': 'application/json'})\n</code></pre> <p>The initialization interface for StreamClient is the same, but the request sending logic is different.</p> <p>This is how StreamClient requests works. <pre><code>&gt;&gt;&gt; async def main(file):\n...     req = aioreq.Request(\"https://google.com\", method=\"GET\")\n...     async with aioreq.StreamClient(request = req) as resp:\n...         async for chunk in resp.content:\n...             file.write(chunk)\n...     file.close()\n</code></pre></p> <p>You can use StreamClient if you don't need a full response right away and want to save a lot of RAM.</p>"}]}