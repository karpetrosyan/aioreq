{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> Aioreq is a Python asynchronous HTTP client library. It is built on top of TCP sockets and implements the HTTP protocol entirely on his own. </p>"},{"location":"#documentation","title":"Documentation","text":"<p>Click here</p>"},{"location":"#install","title":"Install","text":"<p>From pypi <pre><code>$ pip install aioreq\n</code></pre></p> <p>From GitHub <pre><code>$ git clone https://github.com/karosis88/aioreq\n$ pip install ./aioreq\n</code></pre></p> <p><code>Aioreq</code> can be used as a Python library or as a command-line tool to make HTTP requests.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":""},{"location":"#python","title":"Python","text":"<pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; response = aioreq.get(\"http://127.0.0.1:7575/\")\n&gt;&gt;&gt; response.status\n200\n&gt;&gt;&gt; content_type = response.headers[\"content-type\"] # Case insensitive\n&gt;&gt;&gt; response.content\nb'Hello World'\n</code></pre> <p>or in async context</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; \n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         response = await client.get(\"http://127.0.0.1:7575\")\n...         return response\n&gt;&gt;&gt; asyncio.run(main())\n&lt;Response 200 OK&gt;\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p><code>Aioreq</code> cli tools are very similar to curl, so if you've used curl before, you should have no trouble.</p> <pre><code>$ aioreq http://127.0.0.1:7575/cli_doc\nHello World\n</code></pre> <p>When performing HTTP requests, there are a few options available.</p> <ul> <li><code>--method -X</code> Specify HTTP method</li> <li><code>--verbose -v</code> Show HTTP request headers</li> <li><code>--include -i</code> Include HTTP response headers</li> <li><code>--output -o</code>  Output file</li> <li><code>--headers -H</code> Send custom headers</li> <li><code>--data -d</code> HTTP POST data</li> <li><code>--user-agent -A</code> Set User-Agent header</li> </ul> <p>Here are some examples of requests.</p> <pre><code>$ aioreq http://127.0.0.1:7575 $ aioreq http://127.0.0.1:7575/cli_doc -d \"Bob\" -X POST\nUser Bob was created!\n$ aioreq http://127.0.0.1:7575/cli_doc -o /dev/null\n\n$ aioreq http://127.0.0.1:7575/cli_doc -v -H \"custom-header: custom-value\" \\\n\"second-header: second-value\"\n========REQUEST HEADERS========\nuser-agent: python/aioreq\naccept: */*\ncustom-header: custom-value\nsecond-header: second-value\naccept-encoding:  gzip; q=1, deflate; q=1\nHello </code></pre>"},{"location":"#middlewares","title":"Middlewares","text":"<p>Aioreq now supports 'middleware' power.</p>"},{"location":"#the-first-steps-with-middleware","title":"The first steps with middleware","text":"<p>Aioreq provides default middlewares to each client. We can see that middlewares by importing 'default_middlewares'  variable. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; aioreq.middlewares.default_middlewares\n('RetryMiddleWare', 'RedirectMiddleWare', 'CookiesMiddleWare', 'DecodeMiddleWare', 'AuthenticationMiddleWare')\n</code></pre> The first item on this list represents the first middleware that should handle our request (i.e. the closest middleware to our client), while the last index represents the closest middleware to the server.</p> <p>We can pass our modified middlewares tuple to the Client to override the default middlewares. <pre><code>&gt;&gt;&gt; client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])\n</code></pre></p> <p>This client will no longer redirect or retry responses.</p> <p>Also, because aioreq stores middlewares in Client objects as linked lists, we can simply change the head of that linked list to skip the first middleware. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'RetryMiddleWare'\n&gt;&gt;&gt;\n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'RedirectMiddleWare'\n&gt;&gt;&gt; \n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'CookiesMiddleWare'\n</code></pre></p> <p>or  <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares = client.middlewares.next_middleware.next_middleware\n&gt;&gt;&gt; # alternative for client = aioreq.Client(middlewares=aioreq.middlewares.default_middlewares[2:])\n</code></pre></p>"},{"location":"#create-your-own-middlewares","title":"Create your own middlewares!","text":"<p>All 'aioreq' middlewares must be subclasses of the class <code>middlewares.MiddleWare</code></p> <p>MiddleWare below would add 'test-md' header if request domain is <code>www.example.com</code> <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomMiddleWare(aioreq.middlewares.MiddleWare):\n...     async def process(self, request, client):\n...         if request.host == 'www.example.com':\n...             request.headers['test_md'] = 'test'\n...         return await self.next_middleware.process(request, client)\n...\n&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; client.middlewares = CustomMiddleWare(next_middleware=client.middlewares)\n</code></pre> Our CustomMiddleWare will now be the first middleware (i.e. closest to the client). Because 'aioreq' middlewares are stored as linked lists, this pattern works (i.e. same as linked list insert method).</p> <p>Alternatively, we can alter the list of middlewares that the client receives. <pre><code>&gt;&gt;&gt; client = aioreq.Client(middlewares = (CustomMiddleWare, ) + aioreq.middlewares.default_middlewares)\n&gt;&gt;&gt; client.middlewares.__class__.__name__\n'CustomMiddleWare'\n</code></pre></p>"},{"location":"#ssltls","title":"SSL/TLS","text":"<p>Aioreq supports three attributes related to this topic.</p> <ul> <li><code>check_hostname</code> Checks whether the peer cert hostname matches the server domain.</li> <li><code>verify_mode</code> Specifies whether the server certificate must be verified.</li> <li><code>keylog_filename</code> File location for dumping private keys</li> </ul> <p>You can also set the environment variable <code>SSLKEYLOGFILE</code>  instead of specifying <code>keylog_filename</code>.</p> <p>You can use a tool like <code>wireshark</code> to decrypt your <code>HTTPS</code> traffic if you have a file with the private keys.</p> <p>Example:</p> <pre><code>$ export SSLKEYLOGFILE=logs\n</code></pre> <p>Then just run aioreq.</p> <p><pre><code>$ aioreq https://example.com\n$ ls -l\ntotal 8\n-rw-r--r-- 1 user user 406 Dec  5 17:19 logs\n</code></pre> Now, the 'logs' file contains keylogs that can be used to decrypt your TLS/SSL traffic with a tool such as 'wireshark'.</p> <p>Here are a few examples of how to manage the SSL context for your requests.</p> <pre><code>import aioreq\ndont_verify_cert = aioreq.get(\"https://example.com\", verify_mode=False)\nverify_and_dump_logs = aioreq.get(\"https://example.com\", verify_mode=True, keylog_filename=\"logs\")\ndefault_configs = aioreq.get(\"https://example.com\", verify_mode=True, check_hostname=True)\n</code></pre>"},{"location":"#authentication","title":"Authentication","text":"<p>If the <code>auth</code> parameter is included in the request, Aioreq will handle authentication.</p> <p>There are two types of authorization that aioreq can handle. * Digest Authorization * Basic Authorization</p> <p>If the incoming response status code is 401 and the header contains <code>www-authorization</code>, <code>aioreq</code> will attempt each of the schemes until authorization is complete.</p> <p><pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def send_req():\n...     async with aioreq.Client() as cl:\n...         return await cl.get('http://httpbin.org/basic-auth/foo/bar', auth=('foo', 'bar'))\n&gt;&gt;&gt; resp = asyncio.run(send_req())\n&gt;&gt;&gt; resp.status\n200\n</code></pre> Parameter <code>auth</code> should be a tuple with two elements: login and password.</p> <p>Authentication is enabled by <code>AuthenticationMiddleWare</code>, so exercise caution when managing middlewares manually.</p>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>In this benchmarks, we compare <code>aioreq</code> and <code>httpx</code> during 999 asynchronous requests, without caching</p> <p>You can run these tests on your local machine; the directory `aioreq/benchmarks\\ contains all of the required modules. <pre><code>$ cd benchmarks\n$ ./run_tests\nBenchmarks\n---------------------------\naioreq benchmark\nTotal time: 2.99\n---------------------------\nhttpx benchmark\nTotal time: 7.60\n</code></pre></p>"},{"location":"#supported-features","title":"Supported Features","text":"<p>Aioreq support basic features to work with HTTP/1.1.More functionality will be available in future releases. This is the latest version features.</p> <ul> <li>Keep-Alive (Persistent Connections)</li> <li>Middlewares</li> <li>Keylogs</li> <li>Authentication</li> <li>Cookies</li> <li>Automatic accepting and decoding responses. Using <code>Accept-Encoding</code> header</li> <li>HTTPS support, TLS/SSL Verification</li> <li>Request Timeouts</li> </ul>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#headers","title":"Headers","text":"<p>To work with headers, 'Aioreq' provides special 'BaseHeader' subclasses.</p> <p>We can set the Accept header by simply entering it in the 'Headers' field, as shown here. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; headers = aioreq.Headers({'Accept' : 'application/json'})\n</code></pre></p> <p>We can also prioritize values. <pre><code>&gt;&gt;&gt; headers = aioreq.Headers({\"Accept\" : \"application/json; q=1\"})\n</code></pre></p> <p>If you want, you can use the dictionary interface. <pre><code>&gt;&gt;&gt; headers = aioreq.Headers()\n&gt;&gt;&gt; headers['accept'] = 'application/json; q=1'\n</code></pre></p> <p>However, aioreq's special 'BaseHeader' subclasses can also be used.</p> <p>Why should you use header classes? You can use the editor autocomplete to add headers without knowing anything about header syntax.</p> <pre><code>&gt;&gt;&gt; from aioreq import headers as aioheaders\n&gt;&gt;&gt; headers = aioreq.Headers()\n&gt;&gt;&gt; headers.add_header(aioheaders.Accept(\n...    (aioheaders.MimeType.json, 1),\n... ))\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/json; q=1\n</code></pre> <p>First, we should import headers. <pre><code>&gt;&gt;&gt; from aioreq import headers as aioheaders\n</code></pre></p> <p>Then, make a <code>BaseHeader</code> object. <pre><code>&gt;&gt;&gt; header_obj = aioheaders.Accept(\n...     (aioheaders.MimeType.html, 0.5)\n... )\n</code></pre></p> <p>This is the 'Accept' header object, with the value 'application/html; q=0.5,'  where 'q' is the priority for that 'MimeType.' Finally, insert this header into the 'Headers' object. <pre><code>&gt;&gt;&gt; headers.add_header(header_obj)\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/html; q=0.5\n</code></pre></p> <p>We can also add multiple 'Values' in this manner. <pre><code>&gt;&gt;&gt; header_obj = aioheaders.Accept(\n...     (aioheaders.MimeType.html, 0.6),\n...     (aioheaders.MimeType.json, 0.8)\n... )\n&gt;&gt;&gt; headers.add_header(header_obj)\n&gt;&gt;&gt; headers\nHeaders:\naccept:  application/html; q=0.6, application/json; q=0.8\n</code></pre></p> <p>That is, the client accepts both html and json responses, but please provide me with a json response if you support both.</p>"},{"location":"advanced/#client","title":"Client","text":"<p>The <code>Client</code> class offers a high-level API for sending and receiving HTTP/1.1 requests. That is how the 'Client' class works.</p> <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         ...\n</code></pre> <p>To change some default arguments or enable persistent connections, pass arguments through the 'Client.'</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client(headers = {'test' : 'test1'}) as client:\n...         await client.get('http://example.com') # This request includes the 'test' header, which was added by the client.\n...         await client.get('http://example.com', headers = {'test' : 'test2'}) # Overrides the client headers.\n</code></pre> <p>You can also use HTTP/1.1's main feature, persistent connections, to save a significant amount of memory and system  resources by reusing connections rather than creating new ones.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client(persistent_connections = True) as client:\n...         ... # This client can now reuse previously opened connections.\n</code></pre> <p>In order to improve request performance, 'Aioreq' instructs the server to encode HTTP messages if possible.</p> <p>This feature is very useful, but you can disable it for specific 'Client' objects if you want.</p> <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; defaults = aioreq.middlewares.default_middlewares\n&gt;&gt;&gt; custom_middlewares = [md for md in defaults if md != 'DecodeMiddleWare']\n&gt;&gt;&gt; client = aioreq.Client(middlewares=custom_middlewares)\n</code></pre>"},{"location":"quickstart/","title":"Usage","text":""},{"location":"quickstart/#basic-usage","title":"Basic usage","text":"<p>First, import aioreq. <pre><code>&gt;&gt;&gt; import aioreq\n</code></pre> This is a very basic example of usage. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; response = asyncio.run(client.get('http://google.com'))\n&gt;&gt;&gt; response\n&lt;Response 200 OK&gt;\n</code></pre></p> <p>The client's context manager stores all of his connections and files and handles cleanup when we're done with them. This is a suggested setup.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         response = client.get(\"http://google.com\")\n</code></pre> <p>This is how 'response' objects are used. <pre><code>&gt;&gt;&gt; response.request\n&lt;Request GET www.google.com&gt;\n&gt;&gt;&gt; response.status\n200\n&gt;&gt;&gt; response.status_message\n'OK'\n</code></pre></p> <p><code>Aioreq</code> provides complete header control. <pre><code>response.headers\nHeaders:\ndate: Thu, 01 Dec 2022 05:29:09 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text/html; charset=ISO-8859-1\ncross-origin-opener-policy-report-only: same-origin-allow-popups; report-to=\"gws\"\nreport-to: {\"group\":\"gws\",\"max_age\":2592000,\"endpoints\":[{\"url\":\"https://csp.withgoogle.com/csp/report-to/gws/other\"}]}\np3p: CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\"\ncontent-encoding: gzip\nserver: gws\ncontent-length: 16642\nx-xss-protection: 0\nx-frame-options: SAMEORIGIN\n</code></pre> As you can see, there is a 'content-encoding' header, and it is gzip. Aioreq can automatically handle many types of encodings and can easily receive compressed data instead of raw data.</p> <p>This is how accessing the body message works. <pre><code>&gt;&gt;&gt; body = response.content\n&gt;&gt;&gt; type(body) == bytes\nTrue\n&gt;&gt;&gt; type(len(body)) == int\nTrue\n</code></pre> As you can see, the 'content-length' header has the value '16622,' indicating that the incoming data length should be  16622, but our content field contains significantly more data than expected. It's because 'Aioreq' 'automatically told  the server' to use compression for better performance, which is then decoded on the client.</p> <p>If you need to receive very lots of data, use 'StreamClient' instead of 'Client.' 'StreamClient' methods return 'async iterators,' which allow us to receive only a small amount of data per iteration and write it to the hard drive, saving a lot of memory.</p> <pre><code>&gt;&gt;&gt; async def main():\n...     import tempfile\n...     file = tempfile.TemporaryFile()\n...     req = aioreq.Request(\"https://google.com\", method=\"GET\")\n...     async with aioreq.StreamClient(request = get) as resp:\n...         async for chunk in resp.content:\n...             file.write(chunk)\n...     file.close()\n</code></pre>"},{"location":"quickstart/#headers","title":"Headers","text":"<p>This is how Headers are set up. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; headers = aioreq.Headers()\n</code></pre></p> <p>'Aioreq Headers' are objects that are similar to dictionary objects but have some differences.</p> <ul> <li> <p>case-insensitivity <pre><code>&gt;&gt;&gt; headers['my-header'] = 'my-text'\n&gt;&gt;&gt; headers['MY-HeAdEr']\n'my-text'\n</code></pre></p> </li> <li> <p>pretty-print <pre><code>&gt;&gt;&gt; headers\nHeaders:\nmy-header: my-text\n</code></pre></p> </li> <li> <p>aioreq header types compatibility <pre><code>&gt;&gt;&gt; from aioreq import headers\n&gt;&gt;&gt; new_header = aioreq.Headers()\n&gt;&gt;&gt; header_obj = headers.Accept((headers.MimeType.json, 0.5))\n&gt;&gt;&gt; new_header.add_header(header_obj)\n&gt;&gt;&gt; new_header\nHeaders:\naccept:  application/json; q=0.5\n</code></pre></p> </li> </ul>"},{"location":"quickstart/#requests","title":"Requests","text":"<p>There is how to make simple GET request. <pre><code>&gt;&gt;&gt; import aioreq\n&gt;&gt;&gt; async def main():\n...     async with aioreq.Client() as client:\n...         await client.get(\"https://google.com\")\n</code></pre></p> <p>Alternatively, we can create a Request object and send it directly through the client. <pre><code>&gt;&gt;&gt; async def example():\n...     req = aioreq.Request(\n...         url='https://google.com/',\n...         method='GET',\n...         )\n...     await cl.send_request(req)\n</code></pre></p> <p>What about sending path parameters? <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...     url='https://google.com/',\n...     method='GET',\n...     params=(('example_1', 10 ), ('example_2', 20))\n...    )\n</code></pre></p> <p>and perhaps a body message <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...            url='https://google.com',\n...            method='GET',\n...            content=b'Text for the body')\n</code></pre></p> <p>If we want to send a JSON request, we must include the content-type parameter. <pre><code>&gt;&gt;&gt; req = aioreq.Request(\n...        url='https://google.com',\n...        method='GET',\n...        content=b'{\"test\": \"test\"}',\n...        headers = {'content-type': 'application/json'})\n</code></pre></p> <p>Alternatively, we can use JsonRequest. <pre><code>&gt;&gt;&gt; req = aioreq.JsonRequest(\n...        url='https://google.com',\n...        method='GET',\n...        content=b'{\"test\": \"test\"}',\n...       )\n</code></pre></p> <p>Each response object contains his request. The 'request' field provides access to the Request object. <pre><code>&gt;&gt;&gt; response.request\n&lt;Request GET www.google.com&gt;\n</code></pre></p>"},{"location":"quickstart/#clients","title":"Clients","text":"<p>Initialization of the client. <pre><code>&gt;&gt;&gt; client = aioreq.Client()\n</code></pre></p> <p>or <pre><code>&gt;&gt;&gt; async def example():\n...     async with aioreq.Client() as client:\n...         ...\n</code></pre></p> <p>You can provide the client with default headers. The client employs his headers in all of his requests.</p> <pre><code>&gt;&gt;&gt; client = aioreq.Client(headers={'Accept': 'application/json'})\n</code></pre> <p>The initialization interface for StreamClient is the same, but the request sending logic is different.</p> <p>This is how StreamClient requests works. <pre><code>&gt;&gt;&gt; async def main(file):\n...     req = aioreq.Request(\"https://google.com\", method=\"GET\")\n...     async with aioreq.StreamClient(request = req) as resp:\n...         async for chunk in resp.content:\n...             file.write(chunk)\n...     file.close()\n</code></pre></p> <p>You can use StreamClient if you don't need a full response right away and want to save a lot of RAM.</p>"}]}